NUnit

*Class library new (name=project name de los metodos/clases a testear +  NUnitTest)
*Agregar packages:
	-NUnit
	-NUnit3TestAdapter
	-Microsoft.NET.Test.Sdk
*Agregar una clase referenciando a la que voy a testeas + NUnitTests(plural)

	[TestFixture]
	public class CalculationNUnitTests
	{
		[Test]
		public void AddNumbers_TwoIntergers_ReturnsCorrectCalculation()
		{
			//Arrange
			Calculation calc = new Calculation();
			//Act
			int result = calc.AddNumbers(1, 1);
			//Assert
			Assert.AreEqual(2, result);
		}

		[Test]
		public void IsOddNumer_InputOddInterger_OutputsTrue()
		{
			//Arrange
			Calculation calc = new Calculation();
			//Act
			bool result = calc.IsOddNumber(1);
			//Assert
			Assert.IsTrue(result);
			Assert.That(result, Is.EqualTo(true));// otra forma de decir is true
		}
	}

NUnit Assertion Model

Classic Model
Usa metodos separados para cada assert
 - Assert.IsFalse(result);
 - Assert.AreEqual(30, result);//expected,actual

Constraint Model
Usa un solo metodo de la clase Assert para expresar todas las aserciones. La logica que prueba cada asercion se expresa como segundo par√°metro
 - Assert.That(result, Is.False);
 - Assert.That(30, IsEqualTo(result));//actual,expected

Metodos con mas de un parametro
 En caso de tener muchos valores a testear o que el metodo acepte mas de uno, usar [TestCase(parametro)] y q los metodos acepten dicho parametro

[TestCase(parametro)]
[TestCase(parametro, otro parametro)]

		[Test]
		[TestCase(2)]
		[TestCase(4)]
		public void IsOddNumer_InputEvenInterger_OutputsFalse (int a)              	{
			//Arrange
			Calculation calc = new Calculation();
			//Act
			bool result = calc.IsOddNumber(a);
			//Assert
			//Assert.IsFalse(result);
			Assert.That(result, Is.EqualTo(false));
		}

COMBNAR DOS TEST CASES EN UNO

*Utilizar [Expected result= //valor esperado]
*El metodo ahora retorna un valor en vez de void

	[Test]
		[TestCase(2, ExpectedResult = false)]
		[TestCase(1, ExpectedResult = true)]
		public bool IsOddNumer_InputInterger_OutputsTrueIfOdd(int a)
		{
			//Arrange
			Calculation calc = new Calculation();
			//Act
			return calc.IsOddNumber(a);						}

ASSERT DOUBLE VALUES

*Cuando testeo double values, y tengo muchos test cases a probar, el resultado esperado es del primer caso y luego como tercer parametro de Assert.AreEqual indico una variable "delta" q significa hasta q valor se espera q varie el resultado

	[Test]
		[TestCase(1.1, 2.1)]//returns 3.2
		[TestCase(1.1, 2.5)]// 3.6
		[TestCase(1.1, 2.9)]// 4
		public void AddDoubleNumbers_InputTwoDoubleValues_ReturnsDoubleValue(double a, double b)
		{
			//Arrange
			Calculation calc = new Calculation();
			//Act
			double result = calc.AddDoubleNumbers(a, b);
			//Assert
			Assert.AreEqual(3.2, result, .8);
		}
// .8 es la variable delta, significa q los resultados esperados van desde 3.2 (resultado del primer calculo) hasta 4 (resultado del ultimo calculo)

ASSERT STRINGS
[Test]
	public void GreetCustomer_InputTwoStrings_OutputString()
	{
		//Arrange
		Customer customer = new Customer();
		//Act
		string greet = customer.GreetCustomer("Denisse", "Fernandez");
	        //Assert
		Assert.That(greet, Is.EqualTo("Hello Denisse Fernandez"));
	}
*******************************************************************
[Test]
[TestCase("Denisse", "Fernandez", ExpectedResult = "Hello Denisse Fernandez")]
	public string GreetCustomer_InputTwoStrings_OutputString1(string a, string b)
	{
		//Arrange
		Customer customer = new Customer();
		//Act
		return customer.GreetCustomer(a,b);
	}

***********************************************************************
[Test]
public void GreetCustomer_InputTwoStrings_OutputString_RandomValidations()
{
	//Arrange
	Customer customer = new Customer();
	//Act
	string greet = customer.GreetCustomer("Denisse", "Fernandez");
	//Assert
	//Assert.That(greet, Is.EqualTo("Hello Denisse Fernandez"));
	Assert.AreEqual("Hello Denisse Fernandez", greet);

	//Greet contiene Hello
	Assert.That(greet, Does.Contain("Hello"));

	//Contain es case sensitive, para desactivarlo
	Assert.That(greet, Does.Contain("hello").IgnoreCase);

	//Greet comienza con hello
	Assert.That(greet, Does.StartWith("Hello"));

	//Greet termina con Fernandez
	Assert.That(greet, Does.EndWith("Fernandez"));

	//Regex
	Assert.That(greet, Does.Match("Hello [A-Z]{1}[a-z]+ [A-Z]{1}[a-z]"));
// Comienza con 1 letra capital seguido de cantidad variable de letras en minuscula (+), espacio, lo mismo para el apellido
}


STRING NULL VALUES

public class Customer
	{
		public string Greeting { get; set; }
		public string GreetCustomer(string Name, string Lastname)
		{
			
			Greeting = $"Hello {Name} {Lastname}";
			return Greeting;
		}
	}
[Test]
public void GreetCustomer_NotCallMethod_OutputNull()
{
	//Arrange
	Customer customer = new Customer();
	//Act(NO HAGO NADA)

	//Assert
	Assert.IsNull(customer.Greeting);
}

CONSTRUCTOR

private Customer customer;

[SetUp]
public void Setup()
{
	customer = new Customer();
}

*Setup actua como constructor, inicializo objetos q voy a usar en todos los tests


COLLECTIONS(Assert.That(...,IS.EquivalentTo...))

public class Calculation
	{
		public List<int> OddNumbers { get; set; }

		public List<int> GetOddNumbers(int min, int max)
		{
			OddNumbers = new List<int>();
			
			for (int i = min; i < max; i++)
			{
				if (i % 2 != 0)
				{
					OddNumbers.Add(i);
				}
			}
			return OddNumbers;
		}

	}
}

[Test]
public void GetOddNumbers_InputMinMaxRange_OutputsOddsNumbrsBetweenRange()
{
   //Arrange
   //inicializo la lista esperada
   List<int> expectedListOfOddNmbrs = new List<int>() { 1, 3, 5};

   //Act
   var result = calc.GetOddNumbers(0, 6);
   //Assert
   Assert.That(result, Is.EquivalentTo(expectedListOfOddNmbrs));

}

COLLECTIONS HELPER METHODS

[Test]
public void GetOddNumbers_InputMinMaxRange_OutputsOddsNumbrsBetweenRange()
{
	//Arrange
	List<int> expectedListOfOddNmbrs = new List<int>() { 1, 3, 5, 7, 9 };//inicializo la lista esperada
	//Act
	var result = calc.GetOddNumbers(0, 10);
	//Assert
	Assert.That(result, Is.EquivalentTo(expectedListOfOddNmbrs));

	//igual a usar isEquivalentTo el orden de las variables cambia
	//Assert.AreEqual(expectedListOfOddNmbrs, result); 

	//la coleccion contiene un valor x
	//Assert.Contains(7, result);

	//la coleccion contiene un valor x (igual al assert anterior)
	Assert.That(result, Does.Contain(7));

	//todos los valores de la colleccion son unicos
	Assert.That(result, Is.Unique);

	//la coleccion esta ordenada d forma ascendente
	Assert.That(result, Is.Ordered);

	//la coleccion esta ordenada d forma descendiente
	//Assert.That(result, Is.Ordered.Descending);

	//la colleccion no esta vacia
	Assert.That(result, Is.Not.Empty);

	//la coleccion tiene 5 elementos
	Assert.That(result.Count, Is.EqualTo(5));

	//la colleccion no contiene el numero 2
	Assert.That(result, Has.No.Member(2));
			
}

IS.INRANGE
*Checkear si un resultado se encuentra entre un rango de valores

public class Customer
	{
		public string Greeting { get; set; }
		public int Discount { get; set; } = 15;
		public string GreetCustomer(string Name, string Lastname)
		{
			Greeting = $"Hello {Name} {Lastname}";
			Discount = 20;
			return Greeting;
		}
	}

[Test]
public void GreetCustomer_CheckDiscount_OutputBetweenGivenRange()
{
	//Arrange

	//Act
	var result = customer.Discount;
	//Assert
	Assert.That(result, Is.InRange(15, 25));
}
