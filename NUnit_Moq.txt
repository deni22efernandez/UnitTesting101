NUnit MOQ

Cuando testeo una clase con dependencias, crear un mock de la interface dependiente.
Si la clase dependiente no posee una interfaz, no es buena practica crear una solo para usarla como Moq para hacer el test

public interface ILogger
{
	void Message(string mssg);
}
public class LogBook : ILogger
{
	public void Message(string mssg)
	{
		Console.WriteLine(mssg);
	}
}

public class BankAccount
{
	public double Balance { get; set; }
	private ILogger _logBook { get; set; }
	public BankAccount(ILogger logBook)
	{
		Balance = 0;
		_logBook = logBook;
	}
	public bool Deposit(double amount)
	{
		_logBook.Message("Begin deposit transaction");
		Balance += amount;
		return true;
	}
		
}

[TestFixture]
public class BankAccountNUnitTest
{	
[Test]
public void Deposit_InputAmount_OutputsTrue()
{
	//Arrange
	var logBookMock = new Mock<ILogger>();
	bankAccount = new BankAccount(logBookMock.Object);

	//Act
	var result=bankAccount.Deposit(111);

	//Assert
	Assert.IsTrue(result);
	Assert.That(result, Is.True);
	Assert.AreEqual(true, result);
	}
}

MOQ SETUP
Cuando la clase a mockear tiene metodos q tmb tengo q mockear
El resultado de cualquier metodo usando setup es falso

public interface ILogger
{
	void Message(string mssg);
	bool LogToDb(string mssg);
	bool LogBalanceAfterWithDrawal(int balanceAfterWithdrawal);
}
public class LogBook : ILogger
{
	public bool LogBalanceAfterWithDrawal(int balanceAfterWithdrawal)
	{
		if (balanceAfterWithdrawal >= 0)
	{
			Console.WriteLine("Success");
			return true;
	}
		Console.WriteLine("Failure");
		return false;
	}
	public bool LogToDb(string mssg)
	{
		Console.WriteLine(mssg);
		return true;
	}
}


[Test]
public void WithDraw_InputWitdraw100WithBalance200_OutputsTrue()
{
	//Arrange
	var logBookMock = new Mock<ILogger>();

	//LogToDb si le paso al menos un string me debe devolver true
	logBookMock.Setup(x => x.LogToDb(It.IsAny<string>())).Returns(true);

	//LogBalanceAfterWithdrawal si recibe un int mayor o igual a cero debe retornar true
	logBookMock.Setup(x => x.LogBalanceAfterWithDrawal(It.Is<int>(x=>x>=0))).Returns(true);

	//lo mismo usando InRange
	logBookMock.Setup(x => x.LogBalanceAfterWithDrawal(It.IsInRange<int>(int.MinValue, -1, Moq.Range.Inclusive)));

	var bankAccount = new BankAccount(logBookMock.Object);

	//Act
	bankAccount.Deposit(200);
	var result = bankAccount.Withdraw(100);
	//Assert
	Assert.IsTrue(result);
}